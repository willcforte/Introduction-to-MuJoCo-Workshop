import mujoco
import mujoco.viewer
import numpy as np
import matplotlib.pyplot as plt
import time

# Load our XML model
model = mujoco.MjModel.from_xml_path("2R_robotic_arm.xml")
data = mujoco.MjData(model)

# PID controller
Kp = 25.0  # Proportional (default=50.0)
Ki = 0.1   # Integral (default=0.1)
Kd = 1.0   # Derivative (default=2.0)

# Define our trajectory (a sinusoidal wave for each joints)
def desired_trajectory(t):
    amplitude = 0.5
    joint1_desired = amplitude * np.sin(1*np.pi*t)
    joint2_desired = amplitude * np.cos(1*np.pi*t)
    return joint1_desired, joint2_desired
    #return 0.5 * np.sin(2 * np.pi * 0.5 * t), 0.3 * np.cos(2 * np.pi * 0.5 * t)  # Adjust amplitude and frequency

# Computing the control signal generated by PID
def pid_control(target, current, prev_error, integral, dt):
    error = target - current
    integral += error * dt
    derivative = (error - prev_error) / dt
    control_signal = Kp * error + Ki * integral + Kd * derivative
    return control_signal, error, integral

# Launch the simulation
with mujoco.viewer.launch_passive(model, data) as viewer:
    start_time = time.time()
    prev_error = [0, 0]
    integral = [0, 0]

    # logging
    trajectory1 = []
    trajectory2 = []
    signals1 = []
    signals2 = []

    while viewer.is_running():
        current_time = time.time() - start_time
        dt = model.opt.timestep
        
        # Get current joint positions
        current_positions = [data.qpos[0], data.qpos[1]]  # Assuming two joints
        target_positions = desired_trajectory(current_time)
        
        # Compute control signals
        control_signals = []
        for i in range(2):
            control_signal, prev_error[i], integral[i] = pid_control(target_positions[i], current_positions[i], prev_error[i], integral[i], dt)
            control_signals.append(control_signal)
        
        # log data
        trajectory1.append(target_positions[0])
        trajectory2.append(target_positions[1])
        signals1.append(control_signals[0])
        signals2.append(control_signals[1])
        x = np.linspace(0, 10, 500)

        # CHANGE TO True TO TRIGGER LOGGING
        if ((False) and (len(trajectory1) == 500)):
            plt.plot(x, trajectory1)
            plt.plot(x, trajectory2)
            plt.plot(x, signals1)
            plt.plot(x, signals2)
            plt.title("Signals and trajectories until over 1000 timesteps")
            plt.show()

        # Apply control signals
        data.ctrl[0] = control_signals[0]  # First actuator controls first joint
        data.ctrl[1] = control_signals[1]  # Second actuator controls second joint
        
        # Step simulation
        mujoco.mj_step(model, data)
        
        # Update viewer
        viewer.sync()
        time.sleep(dt)
