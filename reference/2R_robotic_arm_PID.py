import mujoco
import mujoco.viewer
import numpy as np
import time

# Load our XML model
model = mujoco.MjModel.from_xml_path("2R_robotic_arm.xml")
data = mujoco.MjData(model)

# PID controller
Kp = 50.0  # Proportional
Ki = 0.1   # Integral
Kd = 2.0   # Derivative

# Define our trajectory (a sinusoidal wave for each joints)
def desired_trajectory(t):
    return 0.5 * np.sin(2 * np.pi * 0.5 * t), 0.3 * np.cos(2 * np.pi * 0.5 * t)  # Adjust amplitude and frequency

# Computing the control signal generated by PID
def pid_control(target, current, prev_error, integral, dt):
    error = target - current
    integral += error * dt
    derivative = (error - prev_error) / dt
    control_signal = Kp * error + Ki * integral + Kd * derivative
    return control_signal, error, integral

# Launch the simulation
with mujoco.viewer.launch_passive(model, data) as viewer:
    start_time = time.time()
    prev_error = [0, 0]
    integral = [0, 0]

    while viewer.is_running():
        current_time = time.time() - start_time
        dt = model.opt.timestep
        
        # Get current joint positions
        current_positions = [data.qpos[0], data.qpos[1]]  # Assuming two joints
        target_positions = desired_trajectory(current_time)
        
        # Compute control signals
        control_signals = []
        for i in range(2):
            control_signal, prev_error[i], integral[i] = pid_control(target_positions[i], current_positions[i], prev_error[i], integral[i], dt)
            control_signals.append(control_signal)
        
        # Apply control signals
        data.ctrl[0] = control_signals[0]  # First actuator controls first joint
        data.ctrl[1] = control_signals[1]  # Second actuator controls second joint
        
        # Step simulation
        mujoco.mj_step(model, data)
        
        # Update viewer
        viewer.sync()
        time.sleep(dt)
